theory ExerciseADH
begin

builtins: symmetric-encryption, diffie-hellman

/*
rule Ltk models a participant generating a fresh public-private key pair
*/

rule Ltk:
  let publicComponent = g^secretKey in	// Generate a public value
  [ Fr(~secretkey) ]
  -->
  [ !Ltk($P, ~secretKey), !Pk($P, publicComponent) , Out(publicComponent) ]
	// Output the long term key, public key and public component

/*
A will use its public value to send a request to B with its public key
*/

rule A_Init:
  [ !Pk($A, publicKeyA) ]	// A should initialize its public key
  --[ ReachAInit() ]->
  [ Out(<'req', $A, $B, publicKeyA>), St_A($A, $B) ]
	// A sends a request to B with its public value/key and stores A and B's public value


rule B_Init:
  let sharedKey = publicKeyA^secretKey	// B calculates the shared key using A's public key
  [ !Ltk($B, ~secretKey), !Pk($A, publicKeyA), ~Pk($B, publicKeyB), In(<'req', $A, $B, publicKeyA) ]	// B initializes its long term key and A's public value and key
  --[ ResponderKey(sharedKey) ]->
  [ Out(<senc('ack', sharedKey), $A, $B, publicKeyB) ]	
	// B outputs its symmetrically encrypted acknowledgement to A with its public value/key


rule A_SendMsg:
  let sharedKey = publicKeyB^~secretKey in  // A calculates the shared key using B's public key
  [ !Ltk($A, ~secretKey), !Pk($B, publicKeyB), Fr(~msg), In(<encryptedAck, $A, $b, publicKeyB>), St_A($A, $B) ]	// A takes in the encrypted acknowledgment and generates a fresh message
  --[ MessageWasSent(~msg), 
      InitiatorKey(sharedKey), 
      Eq('ack', sdec(encryptedAck, sharedKey)) ]->
  [ Out(senc(~msg, sharedKey)) ]
	// A outputs the symmetrically encrypted message with the shared key between A and B

// This restriction allows you to use the Eq action fact in rules to constrain
// that two terms must be equal. This is used to "compare" two messages or
// terms, e.g., to check that signature verification is equal to true.
// This rule is only commented out right now to suppress a warning that Eq is
// referenced but not used. Un-comment it whenever you want!
// restriction Eq:
//   "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

lemma Executability:
  exists-trace
  "Ex #t1 #t2 #t3. ReachAInit() @ #t1 & ReachBInit() @ #t2 & ReachASendMsg() @ #t3"

// K(m) @ #t means that the adversary knows message m at timepoint #t.
// Again, the following lemmas are commented out to suppress warnings.
// lemma ResponderKeySecrecy:
//   "All k #t. ResponderKey(k) @ #t ==> not Ex #x. K(k) @ #x"

// lemma InitiatorKeySecrecy:
//   "All k #t. InitiatorKey(k) @ #t ==> not Ex #x. K(k) @ #x"

// lemma SendMsgSecrecy:
//   "All m #t. MessageWasSent(m) @ #t ==> not Ex #x. K(m) @ #x"

end
