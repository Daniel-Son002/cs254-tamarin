/*

The goal of this exercise is to formalize the insecure version of the Needham-Schroeder protocol and prove that it is insecure.
	1. A -> B: {(A, N_A)}pk(B)
	2. B -> A: {(N_A, N_B)}pk(A)
	3. A -> B: {N_B}pk(B)
Here, pk(A) and pk(B) are public keys with corresponding secret keys, (., .) represents concatenation, and N_A and N_B are random nonces.

*/

theory NSInsecure
begin

/*

This builtin gives us access to 3 function symbols -- aenc, adec, and pk -- satisfying the following equality:
	adec(aenc(m, pk(sk)), sk) = m
Note the distinction between the public key and the secret key, unlike symmetric encryption.

*/
builtins: asymmetric-encryption

// The following rules define the public key infrastructure

// Register new key
rule RegLtk:
	[ Fr(~ltkA) ] // Generate fresh key
	-->
	[ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ] // Save secret and public key, announce public key

// Reveal key
rule RevLtk:
	[ !Ltk($A, ltkA) ] // Look up secret key
	--[ RevLtk(A) ]->
	[ Out(ltkA) ] // Announce secret key

// Send first message
rule A1:
	let m1 = aenc {$A, ~nA} pkB // Encode (A, N_A) with B's public key
	in
	[ Fr(~nA), !Pk($B, pkB) ] // Generate fresh nonce
	-->
	[ Out(m1) ]

// Send second message
rule B1:
	let m1 = aenc {$A, nA} pk(ltkB)
		m2 = aenc {nA, ~nB} pkA
	in
	[ !Ltk($B, ltkB), In(m1), Fr(~nB), !Pk($A, pkA) ]
	-->
	[ Out(m2) ]

// Send third message
rule A2:
	let m2 = aenc {$B, nB} pk(ltkA)
		m3 = aenc {nB} pkB
	in
	[ !Ltk($A, ltkA), In(m2), !Pk($B, pkB) ]
	-->
	[ Out(m3) ]

end