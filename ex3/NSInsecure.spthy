/*

The goal of this exercise is to formalize the insecure version of the Needham-Schroeder protocol and prove that it is insecure.
	1. A -> B: {(A, N_A)}pk(B)
	2. B -> A: {(N_A, N_B)}pk(A)
	3. A -> B: {N_B}pk(B)
Here, pk(A) and pk(B) are public keys with corresponding secret keys, (., .) represents concatenation, and N_A and N_B are random nonces.

*/

theory NSInsecure
begin

/*

This builtin gives us access to 3 function symbols -- aenc, adec, and pk -- satisfying the following equality:
	adec(aenc(m, pk(sk)), sk) = m
Note the distinction between the public key and the secret key, unlike symmetric encryption.

*/
builtins: asymmetric-encryption


// The following rules define the public key infrastructure

// Rule to register new key
rule RegLtk:
	[ Fr(~ltkA) ] // Generate fresh key
	-->
	[ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ] // Save secret and public key, announce public key

// This allows an adversary to retrieve a public key
rule GetPk:
	[ !Pk($A, pkA) ]
	-->
	[ Out(pkA) ]

// This allows us to model a secret key being revealed, but ensured that this is logged by an action
rule RevLtk:
	[ !Ltk($A, ltkA) ] // Look up secret key
	--[ LtkReveal(A) ]->
	[ Out(ltkA) ] // Announce secret key


// We now define our protocol

// Send first message
rule A1:
	let m1 = aenc {$A, ~nA} pkB // Encode (A, N_A) with B's public key
	in
	[ Fr(~nA) // Generate fresh nonce
	, !Pk($B, pkB) // Look up B's public key
	] 
	-->
	[ A1($B, ~nA) // Store recipient and nonce
	, Out(m1) // Output message
	]

// Send second message
rule B1:
	let m1 = aenc {$A, nA} pk(ltkB) // Define message that B recieves
		m2 = aenc {nA, ~nB} pkA // Encode (N_A, N_B) with A's public key
	in
	[ !Ltk($B, ltkB)
	, In(m1)
	, Fr(~nB)
	, !Pk($A, pkA) 
	]
	-->
	[ Out(m2) ]

// Send third message
rule A2:
	let m2 = aenc {$B, nB} pk(ltkA)
		m3 = aenc {nB} pkB
	in
	[ !Ltk($A, ltkA), In(m2), !Pk($B, pkB) ]
	-->
	[ Out(m3) ]

end